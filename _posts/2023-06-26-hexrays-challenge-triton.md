---
title: "Solving Hex-Rays Challenge with Triton and TritonDSE"
excerpt: "Triton is a library for doing Symbolic Execution, useful for doing common CTF challenges and analyzing obfuscations. TritonDSE is a library built on top of Triton which provides easy and customizable Dynamic Symbolic Execution Capabilities"
categories:
    - Symbolic Execution
    - Triton
tags:
    - Python
    - C++
    - ELF
    - Linux
    - Quarkslab
    - Binary Analysis
toc: true
---

<figure>
<a href="/assets/images/hex-ray-challenge/cover.png"><img src="/assets/images/hex-ray-challenge/cover.png"></a>
</figure>

Few weeks ago Robert Yates uploaded a [tweet](https://twitter.com/yates82/status/1662440679459500033), in this video a [challenge](https://hex-rays.com/blog/free-madame-de-maintenon-ctf-challenge/) by the company Hex-Rays with [Binary Ninja](https://binary.ninja/) and the plugin [SENinja](https://github.com/borzacchiello/seninja). So I thought about doing something similar but this time using [Triton](https://triton-library.github.io/) and after that using [TritonDSE](https://blog.quarkslab.com/introducing-tritondse-a-framework-for-dynamic-symbolic-execution-in-python.html). These are two libraries for doing Dynamic Symbolic Execution (DSE). Triton is written in C++ and it offers an API in Python for using it in an easy way, TritonDSE is a library written in Python that relies on Triton offering DSE capabilities in an easier way than Triton (also other useful capabilities like program loading). For the disassembly and the decompilation I will use [Ghidra](https://ghidra-sre.org/), an open source disassembler/decompiler written in Java released by the NSA.

## Authors

* Eduardo Blazquez

## The Challenge

The challenge is an ELF binary for 64 bits dynamically linked with a size of 1,4 Mega bytes, we can obtain all this information with the next command:

```console
$ file challenge 
challenge: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=83db7b297901c743a71f43e813e3dc266245b220, for GNU/Linux 3.2.0, stripped
$ ls -lah challenge 
-rwxrwxr-x 1 symbolic symbolic 1,4M may 17 09:55 challenge
```

The program needs one argument for running, so we will suppose that the program waits some kind of flag, and we have to find it and provide the correct flag for running the program. Let's give it a try, a first time we do not provide any argument, and we obtain a message asking for a password, and then we will provide any password, here I will just write part of the name of a song by *Rainbow*: *"Temple of the King"*. Next you can see what I get:

<figure>
<a href="/assets/images/hex-ray-challenge/1.png"><img src="/assets/images/hex-ray-challenge/1.png"></a>
<figcaption>Running the binary with a password, and with an incorrect password.</figcaption>
</figure>

As we can see, the program renders a PNG file, that just tells us that I'm going in the wrong way, so I need to look for the password in other place (or it can be the program doesn't like Dio's song...).

Instead of doing analysis with other tools, I will just jump to open the binary in a disassembler, as I said at the beginning, I will use Ghidra for the purpose of this challenge.

### Analyzing the Challenge with Ghidra

So for analyzing the binary I will use Ghidra's disassembler and decompiler, using both tools at same time is very useful, since some optimizations are applied to the decompiled code that help us to understand better what is happening, but as we will see, in the binary we can find some decryption loops that the decompiler cannot represent properly.

First of all in Ghidra we have to create a project, the project will contain our disassembled binaries, in my case I created one already, but you can probably look some basic tutorial from Ghidra for learning how to do this (or if you want to dig deeper, I recommend you any of the next books [Ghidra Software Reverse Engineering for Beginners](https://www.packtpub.com/product/ghidra-software-reverse-engineering-for-beginners/9781800207974), or [The Ghidra Book: The Definitive Guide](https://www.ghidrabook.com/)). Once you have created the project, and loaded the binary you'll get a screen like the next:

<figure>
<a href="/assets/images/hex-ray-challenge/2.png"><img src="/assets/images/hex-ray-challenge/2.png"></a>
<figcaption>Ghidra project and loaded binary.</figcaption>
</figure>

If we click on the binary, since Ghidra obtained the address of the `main` function (the first function from the binary written by the programmer), but in any other case we would just jump to the `entry` function, which is the principal function generated by the compiler, and the one where the `e_entry` value from ELF's header point, this function will call to the function `__libc_start_main`, and its first argument (the one loaded into `RDI`) will be the `main` function:

<figure>
<a href="/assets/images/hex-ray-challenge/3.png"><img src="/assets/images/hex-ray-challenge/3.png"></a>
<figcaption>Entry function of the binary.</figcaption>
</figure>

If we double click into the word `main` we will directly go to the `main` function, in my case I already renamed variables, and also I have changed the signature of the function, something you can do clicking on function's name and pressing `F`.

<figure>
<a href="/assets/images/hex-ray-challenge/4.png"><img src="/assets/images/hex-ray-challenge/4.png"></a>
<figcaption>Main function of the binary.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/5.png"><img src="/assets/images/hex-ray-challenge/5.png"></a>
<figcaption>Screen where we can change function's signature.</figcaption>
</figure>

If later you want to rename variables remember that in Ghidra you have to click on variable's name, and then press `L`, or for leaving a comment, you have to press `;`.

If we skip the prologue of the function, we will jump directly to a few calls to what it looks the API from the [*SDL*](https://www.libsdl.org/) library, this library is used to provide access to some hardware and graphics, useful for rendering images and commonly used for video games. We can also see at the beginning the check of the `argc` value, this is checked to be greater than 1, in other case, the program jumps to the error code. Next I leave the assembly code, and also the decompiled code from Ghidra with some comments, and some variables already renamed:

<figure>
<a href="/assets/images/hex-ray-challenge/6.png"><img src="/assets/images/hex-ray-challenge/6.png"></a>
<figcaption>Beginning part of the function in assembly.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/7.png"><img src="/assets/images/hex-ray-challenge/7.png"></a>
<figcaption>Beginning part of the function in pseudo-C.</figcaption>
</figure>

If we continue analyzing the code, we reach a part which assembly highly optimizes, but in the pseudo-code from Ghidra, it looks like an initialization of a big array. The code maybe was generated with a `memset`, but internally the compiler will generate an assembly code which uses the register `xmm0`, this register is set to 0 with a `xor` operation, and then will be used to initialize the first 16 bytes of a buffer. Also we will see an initialization to 0 from the byte 16 to 24. Finally a call to `strncpy` is done with a pointer to `argv[1]` to the initialized pointer. So if we think it a little bit, we can infer this is an initialization of a local buffer, and a copy from the `argv[1]` to that internal buffer. We can set the type of the buffer with Ghidra pressing the key `Y`, and then selecting the type, I chose the type `uint[0x18]`. We could even implement it easily in C:

```c
int main(int argc, char **argv)
{
    char internal_buffer[0x18];
    ...
    memset(internal_buffer, 0, 0x18);
    strncpy(internal_buffer, argv[1], 0x18);
}
```

But with Ghidra we will find something like the next pictures:

<figure>
<a href="/assets/images/hex-ray-challenge/8.png"><img src="/assets/images/hex-ray-challenge/8.png"></a>
<figcaption>Initialization of the local buffer in assembly.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/9.png"><img src="/assets/images/hex-ray-challenge/9.png"></a>
<figcaption>Initialization of the local buffer in pseudo-C.</figcaption>
</figure>

### Starting with the Maths

Since I'm using a DSE engine, with a solver like Z3, readers probably already have realized that in this challenge we will find some math equations to solve, and probably looking for a solution manually would be costly, and highly difficult. Here we will see the different equations from the program, and we will try to represent them, we will see why these equations are important for solving the challenge.

#### First equation

After the call to `strncpy` we find the first equation to solve, and also the first constraints that I will use to feed Z3 in order to properly solve the challenge. Next pictures represent this first equation:

<figure>
<a href="/assets/images/hex-ray-challenge/10.png"><img src="/assets/images/hex-ray-challenge/10.png"></a>
<figcaption>First equation and first constraint in assembly.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/11.png"><img src="/assets/images/hex-ray-challenge/11.png"></a>
<figcaption>First equation and first constraint in pseudo-C.</figcaption>
</figure>

We have the first equation with the first constraint in this pseudo code:

<h:math>
(password[16:18] + password[22:24]) - (password[8:10] + password[14:16]) = 0x1cd4
</h:math>

<br>

#### Second equation

So we have the first constraint, which it means that for the previous operation, Z3 will have to choose values that satisfy that requirement of obtaining the result `0x1cd4`.

Then we can move to the second equation, and the second constraint, which is right below to the code previously seen.

<figure>
<a href="/assets/images/hex-ray-challenge/12.png"><img src="/assets/images/hex-ray-challenge/12.png"></a>
<figcaption>Second equation and second constraint in assembly.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/13.png"><img src="/assets/images/hex-ray-challenge/13.png"></a>
<figcaption>Second equation and second constraint in pseudo-C.</figcaption>
</figure>

Let's represent as I did before, the equation with a more mathematical notation:

<h:math>
(password[6:8] + password[2:4] + password[20:22]) - password[10:12] = 0xd899 
</h:math>

<br>

Again, once we feed Z3 with this constrait, it will have to find another 4 values (again 8 bytes, because each value are `word` size) which solve the equation. In case any of the previous equations do not work, we will go to a code that will render the error PNG, and will apply a cleanup:

<figure>
<a href="/assets/images/hex-ray-challenge/14.png"><img src="/assets/images/hex-ray-challenge/14.png"></a>
<figcaption>Error code in case any of the first or second equation are not correct.</figcaption>
</figure>


#### Third equation and first decryption loop

We will move following the `JZ` instruction and we will see the third equation:

<figure>
<a href="/assets/images/hex-ray-challenge/15.png"><img src="/assets/images/hex-ray-challenge/15.png"></a>
<figcaption>Third equation and third constraint in assembly.</figcaption>
</figure>

We obtain the next equation in a mathematical notation:

<h:math>
password[16:24] &oplus; password[0:8] = 0xa04233a475d1b72
</h:math>

<br>

Again we will use this as a constraint for the used bytes for Z3, and again if this solution is not met, we would jump to the error code, but in case we gave correct values, we would enter in the first decryption loop. The challenge contains an encrypted PNG that will be decrypted using the provided password, so even if we try to bypass the jump instructions without solving correctly the challenge, we would not obtain the correct PNG. If we reached this point without bypassing jumps, and we provided the correct password until now we will reach the next code:

<figure>
<a href="/assets/images/hex-ray-challenge/16.png"><img src="/assets/images/hex-ray-challenge/16.png"></a>
<figcaption>First decryption loop in assembly.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/17.png"><img src="/assets/images/hex-ray-challenge/17.png"></a>
<figcaption>First decryption loop in pseudo-C.</figcaption>
</figure>

While Ghidra is able to recover a decompiled code, it looks a little strange, and applies some difficult to understand mathematical operations, in this case, I recommend following the assembly code, since I think is cleaner, but mostly the algorithm is a loop which applies a decryption operation, using part of our password as key, and this is what it makes the challenge harder, since we have to find a proper password that correctly decrypts the PNG file. **Let's try to keep in mind the addresses of the decryption loop, since it's not interesting for the symbolic execution, and bypassing it we will save time and memory!**

#### Fourth equation and second decryption loop

Once we step out the the first decryption loop, we will have the fourth equation in the code, we can see its assembly and its pseudo-C in the next pictures

<figure>
<a href="/assets/images/hex-ray-challenge/18.png"><img src="/assets/images/hex-ray-challenge/18.png"></a>
<figcaption>Fourth equation and constraint in assembly.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/19.png"><img src="/assets/images/hex-ray-challenge/19.png"></a>
<figcaption>Fourth equation and constraint in pseudo-C.</figcaption>
</figure>

Again we will provide this as a constraint to Z3 in order to obtain more parts from the password, and as part of that, the correct password. I write next the equation used in this part of the code:

<h:math>
((password[0:4] * 2 + password[20:24]) - (password[8:12]*4)) - (password[16:20] >> 3) - (password[4:8] >> 3) = 0x4b5469c
</h:math>

<br>

As before, in case the calculus with the provided password doesn't give as result the value `0x4b5469c`, we will go to the error code that just show the error PNG, but in case the correct password is provided, we directly jump to the second decryption loop.

<figure>
<a href="/assets/images/hex-ray-challenge/20.png"><img src="/assets/images/hex-ray-challenge/20.png"></a>
<figcaption>Second decryption loop in assembly.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/21.png"><img src="/assets/images/hex-ray-challenge/21.png"></a>
<figcaption>Second decryption loop in pseudo-C.</figcaption>
</figure>

Again we have a decryption loop that uses the provided password from the user for decrypting the correct PNG. Again we would be working with a symbolic variable (I'll show it in Triton's part), for that reason what we will do is just step out and jump over this decryption loop. **Keep these addresses too for the symbolic execution**.

#### Last Equation

Once we have finished the second decryption loop we arrive to the final check applied in the program, this will be the last constraint our solver will need for obtaining the password, in the next pictures we can see the last equation, while we cannot see where R8 comes from and which value is used in the assembly, in the decompiled part we can see what addresses are `xored`.


<figure>
<a href="/assets/images/hex-ray-challenge/22.png"><img src="/assets/images/hex-ray-challenge/22.png"></a>
<figcaption>Last equation in assembly.</figcaption>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/23.png"><img src="/assets/images/hex-ray-challenge/23.png"></a>
<figcaption>Last equation in pseudo-C.</figcaption>
</figure>

And here in a more text format as before:

<h:math>
password[16:24] &oplus; passwords[8:16] = 0x231f0b21595d0455
</h:math>

<br>

With this part we would have finished the analysis of the equations and the constraints, we just leave from the program the next code:

<figure>
<a href="/assets/images/hex-ray-challenge/24.png"><img src="/assets/images/hex-ray-challenge/24.png"></a>
</figure>

<figure>
<a href="/assets/images/hex-ray-challenge/25.png"><img src="/assets/images/hex-ray-challenge/25.png"></a>
</figure>

This part of the code just apply a final decryption, and finally it shows the image to the user, so we do not need to know anything more from the challenge for solving it.

If we present all the equations together we get the next:

<h:math>
(password[16:18] + password[22:24]) - (password[8:10] + password[14:16]) = 0x1cd4
<br>
(password[6:8] + password[2:4] + password[20:22]) - password[10:12] = 0xd899 
<br>
password[16:24] &oplus; password[0:8] = 0xa04233a475d1b72
<br>
((password[0:4] * 2 + password[20:24]) - (password[8:12]*4)) - (password[16:20] >> 3) - (password[4:8] >> 3) = 0x4b5469c
<br>
password[16:24] &oplus; passwords[8:16] = 0x231f0b21595d0455
</h:math>

<br>

With Z3 we have to solve all these equations and check if there's a model that can meet al these constraints. Let's directly dig into the analysis with Triton, and after that with TritonDSE, I will cover both scripts, and show how we can use both frameworks for obtaining the password.

## Solving the Challenge With Triton

<figure>
<a href="/assets/images/hex-ray-challenge/triton.png"><img src="/assets/images/hex-ray-challenge/triton.png" style="background-color:white;"></a>
</figure>

As stated on its [website](https://triton-library.github.io/): *Triton is a dynamic binary analysis library. It provides internal components that allow you to build your program analysis tools, automate reverse engineering, perform software verification or just emulate code.*

In the web site we can also find the architecture of Triton:

<figure>
<a href="/assets/images/hex-ray-challenge/triton_arch.png"><img src="/assets/images/hex-ray-challenge/triton_arch.png"></a>
</figure>

What we will do with Triton is emulating the code, and set part of that memory as symbolic. Once Triton runs the code from the program, it will start creating an expression using the symbolic variables, from this expression we can retrieve an Abstract Syntax Tree (AST) representation. We will apply different constraints to the expressions, and then use Z3 for solving it and obtaining the password. We will go over the next steps:

1. Create hooks for different library functions not implemented in Triton.
2. Analyze the binary with Lief.
3. Load the binary.
4. Emulate the binary, here we will apply library hooks and our own hooks.
5. Apply constraints in certain points.
6. Solve the final expression with the constraints

In this part of the blog I will copy different part of the scripts, but you can find the code of the script in [here](https://github.com/Fare9/My-Symbolic-Execution/blob/master/IDA-challenge/free-madame-de-maintenon-challenge/triton_solver.py).

Triton is a library focused on the analysis part, so things like loading the binary, applying relocations, or allocating the memory are not automatically done by the library, and are left to the analyst. Also the implementation of standard functions will be our work, but we can go over a few examples from Triton's web page. Here we will see some of these functions, and then we will go with the code for solving the challenge.


### Creating Hooks for Library Functions

First, let's see how to create a hook for the function `__libc_start_main`, in this function we will provide the code for giving the arguments to the program, the next code will be used in almost all the Triton scripts:

```python
def libc_start_main(ctx):
    print('[+] __libc_start_main hooked')

    # Get arguments
    main = ctx.getConcreteRegisterValue(ctx.registers.rdi)

    # Push the return value to jump into the main() function
    ctx.setConcreteRegisterValue(ctx.registers.rsp, ctx.getConcreteRegisterValue(ctx.registers.rsp)-CPUSIZE.QWORD)

    # set as return value the address of main
    # avoid all the libc stuff
    ret2main = MemoryAccess(ctx.getConcreteRegisterValue(ctx.registers.rsp), CPUSIZE.QWORD)
    ctx.setConcreteMemoryValue(ret2main, main)

    # Setup argc / argv
    ctx.concretizeRegister(ctx.registers.rdi)
    ctx.concretizeRegister(ctx.registers.rsi)

    # here write all the needed arguments
    argvs = [
        bytes(TARGET.encode('utf-8')),  # argv[0]
        b'A'*0x18 + b'\00'
    ]

    # Define argc / argv
    base  = BASE_ARGV
    addrs = list()

    # create the arguments
    index = 0
    for argv in argvs:
        addrs.append(base)
        ctx.setConcreteMemoryAreaValue(base, argv+b'\x00')
        base += len(argv)+1
        print('[+] argv[%d] = %s' %(index, argv))
        index += 1

    # set the pointer to the arguments
    argc = len(argvs)
    argv = base
    for addr in addrs:
        ctx.setConcreteMemoryValue(MemoryAccess(base, CPUSIZE.QWORD), addr)
        base += CPUSIZE.QWORD

    # finally set RDI and RSI values
    ctx.setConcreteRegisterValue(ctx.registers.rdi, argc)
    ctx.setConcreteRegisterValue(ctx.registers.rsi, argv)

    return (CONCRETE, 0)
```

We will also create a hook for the function `strncpy`, the function is used to copy the `argv[1]` into a local buffer in the stack, this local buffer represents the password provided by the user. Since this buffer is the one we want to know the different values, we will set this buffer as *symbolic* in order to apply symbolic execution, and obtain the different expressions.

```python
def strncpy(triton_ctx):
    global MEM_ADDRESS_BUFFER

    print("[+] strncpy hooked")
    # get rdi the first argument to be hooked
    rdi = triton_ctx.getConcreteRegisterValue(triton_ctx.registers.rdi)

    print("Symbolizing the user input in the address 0x%08X" % rdi)

    # save the value
    MEM_ADDRESS_BUFFER = rdi

    # because we want the password to have only ASCII values,
    # retrieve the minimum possible value
    # and the maximum value 
    valid_characters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~"
    min_value = ord(min(valid_characters))
    max_value = ord(max(valid_characters))

    for i in range(0x18):
        memory_byte = MemoryAccess(rdi+i, CPUSIZE.BYTE)
        # set first a concrete value (concolic)
        triton_ctx.setConcreteMemoryValue(memory_byte, 61)
        # symbolize the memory address for extracting the expression
        triton_ctx.symbolizeMemory(memory_byte, "flag_%d" % (i))
        # add the ascii string constraints
        triton_ctx.pushPathConstraint(triton_ctx.getMemoryAst(memory_byte) >= min_value)
        triton_ctx.pushPathConstraint(triton_ctx.getMemoryAst(memory_byte) <= max_value)

    # finally set a 0 value (end of string)
    triton_ctx.setConcreteMemoryValue(MemoryAccess(rdi+0x18, CPUSIZE.BYTE), 0)
    # return the strncpy value as a concrete value
    return (CONCRETE, 0x18)
```

Here I have push some constraints already, since we want a password with ANSII values, we will add two constraints for each value, it must be bigger than a minimum value from ANSII characters, and lower-equals to a max value from those ANSII characters. For setting the memory as symbolic we use `symbolizeMemory`, and for creating a constraint we use `pushPathConstraint`. Since the symbolic execution can be expensive, we concretize that memory with a concrete value in this case value `A`, this is what is called *Concolic Execution*.

Finally we will have a structure that we will use to call these hooks, together with a function that will call the hooks during emulation, it is the next code:

```python
# the third value will be assigned during relocation.
customRelocation = [
    ['strncpy', strncpy, None],
    ['__libc_start_main', libc_start_main, None]
]

...

def hookingHandler(ctx):
    '''
    In case one of the run address is one from
    the emulated functions, just call it and
    get the result, check if it's needed to symbolize
    the output register.

    :param ctx: Triton's context for emulation.
    '''
    pc = ctx.getConcreteRegisterValue(ctx.registers.rip)
    for rel in customRelocation:
        if rel[2] == pc:
            # Emulate the routine and the return value
            state, ret_value = rel[1](ctx)
            if ret_value is not None:
                ctx.setConcreteRegisterValue(ctx.registers.rax, ret_value)
                if state is SYMBOLIC:
                    print(f'[+] Symbolizing the return value')
                    ctx.symbolizeRegister(ctx.registers.rax)
            # Get the return address
            ret_addr = ctx.getConcreteMemoryValue(MemoryAccess(ctx.getConcreteRegisterValue(ctx.registers.rsp), CPUSIZE.QWORD))
            # Hijack RIP to skip the call
            ctx.setConcreteRegisterValue(ctx.registers.rip, ret_addr)
            # Restore RSP (simulate the ret)
            ctx.setConcreteRegisterValue(ctx.registers.rsp, ctx.getConcreteRegisterValue(ctx.registers.rsp)+CPUSIZE.QWORD)
    return
```

### Analyzing and Loading Binary

For obtaining some data from the binary, we will use *Lief* a parser library that will allow us to obtain information like sections from the binary, relocations, and so on. Then we will load the binary into memory for doing the analysis. First, we will write some constants with the memory structure we want:

```python
# Memory mapping
BASE_PLT   = 0x10000000
BASE_ARGV  = 0x20000000
BASE_STACK = 0x9ffffff0
ERRNO      = 0xa0000000
```

Then we need a code that goes section by section loading the binary into memory:

```python
def loadBinary(triton_ctx, lief_binary):
    phdrs = lief_binary.segments
    for phdr in phdrs:
        size    = phdr.physical_size
        vaddr   = phdr.virtual_address
        print("[+] Loading 0x%06x - 0x%06x" % (vaddr, vaddr+size))
        triton_ctx.setConcreteMemoryAreaValue(vaddr, list(phdr.content))
    return
```

And finally, we need to apply relocations from the functions in the PLT, we will use the addresses from the imported functions to set the last values from `customRelocation` structure:

```python
def makeRelocation(ctx, binary):
    # Setup plt
    print("[+] Applying relocations and extracting the addresses for the external functions")

    for pltIndex in range(len(customRelocation)):
        customRelocation[pltIndex][2] = BASE_PLT + pltIndex

    relocations = [x for x in binary.pltgot_relocations]
    relocations.extend([x for x in binary.dynamic_relocations])

    # Perform our own relocations
    for rel in relocations:
        symbolName = rel.symbol.name
        symbolRelo = rel.address
        for crel in customRelocation:
            if symbolName == crel[0]:
                print('[+] Init PLT for: %s' %(symbolName))
                ctx.setConcreteMemoryValue(MemoryAccess(symbolRelo, CPUSIZE.QWORD), crel[2])
                break
    return
```

### Emulate the Binary

First of all we can create a `run` function that will initialize the stack registers (`RBP` and `RSP`) creating a kind of *fake stack*, and that function will call the emulation one:

```python
def run(triton_ctx, binary):
    # define a fake stack
    triton_ctx.setConcreteRegisterValue(triton_ctx.registers.rbp, BASE_STACK)
    triton_ctx.setConcreteRegisterValue(triton_ctx.registers.rsp, BASE_STACK)

    # Emulate binary from the entry point
    print("[+] Starting emulation from entry point 0x%08X" % (binary.entrypoint))
    d1 = time.time()
    emulate(triton_ctx, binary.entrypoint)
    d2 = time.time()
    print("[+] Emulation finished.")
    print("Time emulation: %.2f milliseconds" % ((d2-d1)*1000))
```

Finally, the emulation function. This function will follow the next process, it will read the opcodes from the memory pointed by the current `program counter` register, it will disassembly that instruction, then we will tell Triton to apply the semantic of the instruction calling its function `processing`, and finally we will advance the pointer to the next instruction.

```python
def emulate(ctx, pc):
    # emulation loop
    while pc:
        opcodes = ctx.getConcreteMemoryAreaValue(pc, 16)
        instruction = Instruction(pc, opcodes)

        '''
        You can insert some logic here
        '''

        # process the instruction
        ret = ctx.processing(instruction)
        # if HALT, finish the execution
        if instruction.getType() == OPCODE.X86.HLT:
            break
        # apply one of the handlers that are not provided by
        # Triton
        hookingHandler(ctx)
        # Next
        pc = ctx.getConcreteRegisterValue(ctx.registers.rip)
```

Previous code represents a common emulation function for Triton, this body of function can be used almost in any analysis. Before moving to the next instruction we called `hookingHandler`, a function that will call our hooks. I left a comment where we can insert some logic of analysis, apply symbolization of registers or memory, apply constraints and finally solve the expressions for getting a model.

### Apply Constraints

Before I didn't paste the whole code for `emulate`, but I will paste here and I will give some explanations more:

```python
def emulate(ctx, pc):

    check_register_value = [
        [FIRST_CONDITIONAL, ctx.registers.eax, 0x1cd4], # 0x000012bf
        [SECOND_CONDITIONAL, ctx.registers.eax, 0xd899], # 0x000012e0
        [THIRD_CONDITIONAL, ctx.registers.rdx, 0xa04233a475d1b72], # 0x000013c5
        [FOURTH_CONDITIONAL, ctx.registers.eax, 0x4b5469c], # 0x00001447
        [FIFTH_CONDITIONAL, ctx.registers.r8, 0x231f0b21595d0455] # 0x00001492
    ]

    loop_address_dest = [
        [FIRST_LOOP, 0x0000141d],
        [SECOND_LOOP, 0x00001483]
    ]

    # emulation loop
    while pc:

        #print("[-] Running instruction at address: 0x%08X" % (pc))
        opcodes = ctx.getConcreteMemoryAreaValue(pc, 16)
        instruction = Instruction(pc, opcodes)

        # call a not implemented function, jump over it
        # adding the length of a call instruction
        if pc in [0x0000124a, 0x00001254, 0x0000126d]:
            print("Not emulated function, continue")
            pc = ctx.getConcreteRegisterValue(ctx.registers.rip)
            pc += 5
            continue
        # avoid decryption loops
        avoid_loop = False
        for val in loop_address_dest:
            if pc == val[0]:
                print("Decryption loop address 0x%08X, moving to 0x%08X" % (val[0], val[1]))
                pc = val[1]
                avoid_loop = True
                break

        if avoid_loop:
            continue

        # conditions
        for val in check_register_value:
            if pc == val[0]:
                print("Checking at address: 0x%08X" % (val[0]))
                if pc == FIFTH_CONDITIONAL:
                    # in this case provide True for solving the expression
                    solver_check(ctx, val[1], val[2], True)
                    return
                else:
                    solver_check(ctx, val[1], val[2])

        # process the instruction
        ret = ctx.processing(instruction)
        # if HALT, finish the execution
        if instruction.getType() == OPCODE.X86.HLT:
            break
        # apply one of the handlers that are not provided by
        # Triton
        hookingHandler(ctx)

        # Next
        pc = ctx.getConcreteRegisterValue(ctx.registers.rip)
```

First of all, as I said during the analysis of the binary, we will avoid two things, functions that are not implemented, and are not important for the analysis, we annotated the addresses of the calls, and we skipped them with the next code:

```python
# call a not implemented function, jump over it
# adding the length of a call instruction
if pc in [0x0000124a, 0x00001254, 0x0000126d]:
    print("Not emulated function, continue")
    pc = ctx.getConcreteRegisterValue(ctx.registers.rip)
    pc += 5
    continue
```

FInally, another important part were the decryption loops, I also said we can avoid these decryption loops since are not important for the analysis, and would present a time and memory consumption:

```python
# avoid decryption loops
avoid_loop = False
for val in loop_address_dest:
    if pc == val[0]:
        print("Decryption loop address 0x%08X, moving to 0x%08X" % (val[0], val[1]))
        pc = val[1]
        avoid_loop = True
        break

if avoid_loop:
    continue
```

Finally, we have the next code:

```python
# conditions
for val in check_register_value:
    if pc == val[0]:
        print("Checking at address: 0x%08X" % (val[0]))
        if pc == FIFTH_CONDITIONAL:
            # in this case provide True for solving the expression
            solver_check(ctx, val[1], val[2], True)
            return
        else:
            solver_check(ctx, val[1], val[2])
```

This code will check the address, and it will call `solver_check`, in this function we will apply the constraints, the second parameter of the function is a register from and the third parameter a value, both used for applying a constraint:

```python
def solver_check(ctx, register, CHECK_VALUE, solve = False, show_ast = False):
    # get the register AST
    reg = ctx.getRegisterAst(register)
    
    # add the constraint
    ctx.pushPathConstraint(reg == CHECK_VALUE)

    if show_ast:
        # in case user wants, show the AST of the expression
        ast = ctx.getAstContext()
        reg_ast = ast.unroll(reg)
        print(reg_ast)

    ...

    # to meet the comparison, set the value of the register
    # to the value checked.
    ctx.setConcreteRegisterValue(register, CHECK_VALUE)
```

The previous code will apply the different constraints once the execution reach the different comparisons, and finally it will set the constant value into the register used in the comparison to keep running properly.

### Solve the final expression with the constraints

We are almost over with Triton, in `solver_check` I didn't past some code that will run if the parameter `solve` is set to `True`, this part of the code will apply a final constraint, and will get the expression from the AST, then it will try to solve it with Z3, and obtain a model:

```python
if (solve):
    # solve and retrieve the flag
    cstr = ctx.getPathPredicate()
    m = ctx.getModel(cstr)
    key_values = {}

    for k, v in m.items():
        key_values[k] = v
    
    flag = ""
    for k in sorted(key_values.keys()):
        v = key_values[k]
        symbar = ctx.getSymbolicVariable(k)
        #print(f"{symbar} ({k}) = {hex(v.getValue())} ({chr(v.getValue())})")
        flag += chr(v.getValue())
    print("\n\n------------------------------------------")
    print(f"Flag={flag}")
    print("------------------------------------------\n\n")
```

Using the previous code, we obtain the expression and tries to get a model that solves the obtained expression with the different constraints. If we obtain each one of the values from the solution we will get something like this:

```console
$ python3 triton_solver.py
...
flag_0:8 (0) = 0x46 (F)
flag_1:8 (1) = 0x72 (r)
flag_2:8 (2) = 0x33 (3)
flag_3:8 (3) = 0x33 (3)
flag_4:8 (4) = 0x5f (_)
flag_5:8 (5) = 0x4d (M)
flag_6:8 (6) = 0x34 (4)
flag_7:8 (7) = 0x64 (d)
flag_8:8 (8) = 0x61 (a)
flag_9:8 (9) = 0x6d (m)
flag_10:8 (10) = 0x33 (3)
flag_11:8 (11) = 0x2d (-)
flag_12:8 (12) = 0x44 (D)
flag_13:8 (13) = 0x65 (e)
flag_14:8 (14) = 0x2f (/)
flag_15:8 (15) = 0x4d (M)
flag_16:8 (16) = 0x34 (4)
flag_17:8 (17) = 0x69 (i)
flag_18:8 (18) = 0x6e (n)
flag_19:8 (19) = 0x74 (t)
flag_20:8 (20) = 0x65 (e)
flag_21:8 (21) = 0x6e (n)
flag_22:8 (22) = 0x30 (0)
flag_23:8 (23) = 0x6e (n)
```

But let's printing it as a string, and will show it in a nice way :D

```console
$ python3 triton_solver.py 
[+] Loading 0x000040 - 0x000318
[+] Loading 0x000318 - 0x000334
[+] Loading 0x000000 - 0x000a88
[+] Loading 0x001000 - 0x001d11
[+] Loading 0x002000 - 0x0021d0
[+] Loading 0x003d28 - 0x15df4c
[+] Loading 0x003d38 - 0x003f48
[+] Loading 0x000338 - 0x000368
[+] Loading 0x000368 - 0x0003ac
[+] Loading 0x000338 - 0x000368
[+] Loading 0x002038 - 0x002084
[+] Loading 0x000000 - 0x000000
[+] Loading 0x003d28 - 0x004000
[+] Applying relocations and extracting the addresses for the external functions
[+] Init PLT for: strncpy
[+] Init PLT for: __libc_start_main
[+] Starting emulation from entry point 0x00001500
[+] __libc_start_main hooked
[+] argv[0] = b'./challenge'
[+] argv[1] = b'AAAAAAAAAAAAAAAAAAAAAAAA\x00'
Not emulated function, continue
Not emulated function, continue
Not emulated function, continue
[+] strncpy hooked
Symbolizing the user input in the address 0x9FFFFF80
Checking at address: 0x000012BF
Checking at address: 0x000012E0
Checking at address: 0x000013C5
Decryption loop address 0x000013CE, moving to 0x0000141D
Checking at address: 0x00001447
Decryption loop address 0x00001452, moving to 0x00001483
Checking at address: 0x00001492


------------------------------------------
Flag=Fr33_M4dam3-De/M4inten0n
------------------------------------------
```

Finally we obtain a password or flag: *Fr33_M4dam3-De/M4inten0n*. Now let's try running it as parameter for our challenge:

<figure>
<a href="/assets/images/hex-ray-challenge/26.png"><img src="/assets/images/hex-ray-challenge/26.png"></a>
<figcaption>Solution for the challenge.</figcaption>
</figure>

## Solving the Challenge With TritonDSE

TritonDSE is a library built on top of Triton, it provides a more high-level program exploration and analysis primitives as stated on Quarkslab [post](https://blog.quarkslab.com/introducing-tritondse-a-framework-for-dynamic-symbolic-execution-in-python.html), it offers a a `callback manager` that allows implementing different hooking methods. TritonDSE offers a SymbolicExplorator that will try to do path exploration generating new values for going over the different branches of the code. Another good point is that TritonDSE already loads the binary by itself, and it contains some API functions from `libc` already implemented, making analysts work easier.

The library was released recently, and it can present some issues yet, but it looks very promising for doing binary analysis. Sadly I didn't take too much time for doing the challenge, so probably I didn't use TritonDSE properly, in any case, I will show my solution using TritonDSE, and probably in the future once I learn more about it and I will improve the script to solve the challenge in a more automatic way. This time I reduce a lot the number of steps so I will explain the solution only on three steps:

1. Load binary (create starting values, set callbacks and run executor)
2. Skip not emulated functions, loops and set bytes constraints.
3. Set constraints and solve the challenge.

### Load Binary, configure starting values, configure callbacks and Run!

The process of loading the binary. and configure some values or callbacks is much easier with TritonDSE since it abstracts many of the internals from Triton. We load the binary calling to the function `Program` and giving the path to the file as argument. Then we can generate the arguments of the program as a `Seed` object, that later will be given as parameter to the `SymbolicExecutor`. This `SymbolicExecutor` object will get the `load` the `Program` object, it also contains a `callback_manager` where we can register the different callbacks, I recommend going through the documentation for understanding all possible callbacks. In my case I only used one callback before each run instruction, and one callback after running each instruction. Next is the `main` function from my script:

```python
def main():
    global p

    # load the target into the engine
    p = Program(TARGET)

    # now generate the first seed values
    config = Config(coverage_strategy=CoverageStrategy.PATH, debug=True,
                pipe_stdout=True, seed_format=SeedFormat.COMPOSITE)
    seed = Seed(CompositeData(argv=[b"./challenge", b"A"*0x18]))

    # create a symbolic explorator to go
    # symbolically over the program
    executor = SymbolicExecutor(config, seed)
    executor.load(p)
    
    # set the callbacks for pre and post instruction
    executor.callback_manager.register_pre_instruction_callback(trace_inst)
    executor.callback_manager.register_post_instruction_callback(skip)

    executor.run()
```

As you can see the code is pretty straightforward which is nice from the point of view of an analysis, so we do not need to write many lines of code for loading a program, and apply relocations, etc.

### Skip not emulated functions, loops and set bytes constraints

I've found that if I try to skip a function in a *pre* callback, or in the hook of an `API` call, the program crashed or it didn't work. In the case of the `API` calls, it crashes because the `__default_stub` function is called when a call to a not supported `API` is run, and the program tries to obtain an address using the `program_counter`, you can find the code [here](https://github.com/quarkslab/tritondse/blob/main/tritondse/symbolic_executor.py#L496C9-L496C16). But because in the hook of the `API` I modify the `RIP` register, the value accessed in Python's map doesn't exist and program crashes.

As I did with Triton's code, for skipping a function, what I do is wait until the `call` instruction is run, and then I recover the return address into `RIP` register, and I fix stack pointer `RSP` for cleaning up the stack. In the case of the decryption loops, I just modify the `RIP` register, and set its address to the address after the decryption loop. Finally, when the call to `strncpy` has finished, I push the ASCII constraints into each byte from the `argv[1]` value, I use the variable `MEM_ADDRESS` which holds `argv[1]` address, in next section I show where this variable is written.

```python
def skip(se: SymbolicExecutor, pstate: ProcessState, inst: Instruction):
    pc = inst.getAddress()
    if pc in [0x0000124a, 0x00001254, 0x0000126d]: # useless calls
        print("[+] Not emulated function, continue")
        # restore rip to a correct one
        pstate.write_register(pstate.registers.rip, pc + inst.getSize())
        # fix rsp
        rsp = pstate.read_register(pstate.registers.rsp)
        pstate.write_register(pstate.registers.rsp, rsp+8)
        return
    
    if pc == 0x000012a0: # post strncpy
        valid_characters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~"
        min_value = ord(min(valid_characters))
        max_value = ord(max(valid_characters))
        print("[+] strncpy adding constraints to symbolized memory")
        # apply the constraint to the AST of each byte
        for i in range(0x18):
            sym_mem = pstate.read_symbolic_memory_byte(MEM_ADDRESS+i)
            pstate.push_constraint(sym_mem.getAst() >= min_value)
            pstate.push_constraint(sym_mem.getAst() <= max_value)
    
    for value in loop_address_dest: # for stepping out the loops
        if pc == value[0]:
            print("[+] Found call to decryption loop, skipping")
            pstate.write_register(pstate.registers.rip, value[1])
            return
```

### Set constraints and solve the challenge.

Finally, we have the callback run before each instruction. In this callback I will push different constraints in the expressions, and once we reach the last comparison, I will push the last constraint, and solve the the challenge looking for a model that meet all the expressions. As I previously said, I also store the address from `argv[1]` into the variable `MEM_ADDRESS`, this is done in the call to `strncpy` where the address is one of the parameters.

```python

def trace_inst(se: SymbolicExecutor, pstate: ProcessState, inst: Instruction):
    global MEM_ADDRESS

    pc = pstate.read_register(pstate.registers.rip)
    
    ...

    if pc == 0x000012a0: # call to strncpy
        rsi = pstate.read_register(pstate.registers.rsi)
        print("[+] Strncpy getting source value: 0x%08X" % (rsi))
        # save address of argv
        MEM_ADDRESS = rsi
    
    for value in check_register_value:
        # go over the jumps of each check
        # and apply the constraint with the used
        # register.
        if pc == value[0]:
            print("[-] Found jump instruction, skipping it")
            sym_reg = pstate.read_symbolic_register(value[1])
            pstate.push_constraint(sym_reg.getAst() == value[2])
            # to make sure the comparison always match
            pstate.write_register(pstate.registers.zf, 1)
    # Last constraint and solution of the system
    if pc == FIFTH_CONDITIONAL:
        print("[!] Got final instruction!")
        sym_r8 = pstate.read_symbolic_register(pstate.registers.r8)
        sym_rax = pstate.read_symbolic_register(pstate.registers.rax)
        status, model = pstate.solve(sym_r8.getAst() == sym_rax.getAst())

        # If formula is SAT retrieve input values
        if status == SolverStatus.SAT:
            # Retrieve value of the input variable involved in the cl value here (shall be only one here)
            sym_mem = pstate.read_symbolic_memory_bytes(MEM_ADDRESS, 0x18)
            var_values = pstate.get_expression_variable_values_model(sym_mem, model)
            key_values = {}
            for var, value in var_values.items():
                key_values[var.getId()] = value
            
            flag = ""
            for k in sorted(key_values.keys()):
                v = key_values[k]
                flag += chr(v)
            print("\n\n------------------------------------------")
            print(f"Flag={flag}")
            print("------------------------------------------\n\n")
            sys.exit(0)
        else:
            print(status.name)
```

The structure `check_register_value` is pretty similar to the one shown in Triton's part, and the code is pretty similar. In case the program counter address is one of the one from `check_register_value`, we push a new constraint where the given register must be the same to the provided value, then we set `ZF` (zero flag) to 1, so the comparison will be true. Finally, if the address is the last condition, we push a final constraint and solve the expression as I did before.

If we run the script, we will get the next output:

<figure>
<a href="/assets/images/hex-ray-challenge/27.png"><img src="/assets/images/hex-ray-challenge/27.png"></a>
<figcaption>Running TritonDSE script and getting the password.</figcaption>
</figure>

As we can see, the output is similar to the previous one from Triton's script but with some logging code. Again we obtain the correct password, and running the challenge with the password will give us the same result. So with this we have finished with the part of TritonDSE!!! 

You can find the full script for this challenge in [here](https://github.com/Fare9/My-Symbolic-Execution/blob/master/IDA-challenge/free-madame-de-maintenon-challenge/tritondse_solver.py).

## Conclusions

I have found the challenge interesting and at the end not so difficult. From a reverse engineering point of view the binary is not hard to analyze, but the problem would be looking for solutions manually, or using brute force, or using other tools manually (we can solve this challenge writing a script for Z3 but this would take longer).

Regarding Triton or TritonDSE, I have found that while in both cases the documentation is a little bit *"tough"* to follow, but with a few examples and reading at same time documentation and source code, you can quickly write scripts useful for doing challenges like this, or even more difficult ones.

Finally I hope you enjoyed reading this post, this time it was a long post, but I think it was needed for understanding the challenge, and the process for solving it.

I want to thank [Yates82](https://twitter.com/yates82) for his video solving the challenge with Binary Ninja, this video gave me the idea for doing the challenge using the covered tools and write the post. Also I want to thank [JonathanSalwan](https://twitter.com/JonathanSalwan), the main author of Triton, I think this tool is very useful and it offers a very high performance. And finally thank [RobinDavid1](https://twitter.com/RobinDavid1) and Christian Heitman, authors of TritonDSE, I think this will make Triton more accessible, and easy to use, which will probably make more people using it.

See you Space Cowboy!